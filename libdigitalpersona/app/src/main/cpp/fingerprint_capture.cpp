#include "fingerprint_capture.h"
#include <android/log.h>
#include <cstring>
#include <unistd.h> // For usleep
#include <stdint.h> // For uintptr_t

// Include libfprint headers
extern "C" {
#include <glib.h>
#include <glib-object.h>
#include <libfprint-2/fprint.h>
#include <libusb-1.0/libusb.h> // For libusb_wrap_sys_device
#include <gusb-1/gusb/gusb-context-private.h> // For _g_usb_context_get_context
#include <dlfcn.h> // For dlsym
}

// Define FpContextPrivate structure to access internal data
// This matches the structure in libfprint/fp-context.c
typedef struct {
    GUsbContext  *usb_ctx;
    GCancellable *cancellable;
    GSList       *sources;
    gint          pending_devices;
    gboolean      enumerated;
    GArray       *drivers;
    GPtrArray    *devices;
} FpContextPrivate;

// Function to get private data from FpContext
// G_DEFINE_TYPE_WITH_PRIVATE creates this function automatically
// We need to declare it here since it's not in public API
// The function name is: fp_context_get_instance_private
extern "C" {
    // This function is generated by G_DEFINE_TYPE_WITH_PRIVATE macro
    // Signature: gpointer fp_context_get_instance_private(FpContext* self)
    // We'll use GObject introspection to get it
    typedef gpointer (*FpContextGetInstancePrivateFunc)(FpContext*);
}

#include <android/log.h>
#define ANDROID_LOG_TAG "FingerprintCapture"
#define ANDROID_LOG(...) __android_log_print(ANDROID_LOG_INFO, ANDROID_LOG_TAG, __VA_ARGS__)
#define ANDROID_LOGW(...) __android_log_print(ANDROID_LOG_WARN, ANDROID_LOG_TAG, __VA_ARGS__)
#define ANDROID_LOGE(...) __android_log_print(ANDROID_LOG_ERROR, ANDROID_LOG_TAG, __VA_ARGS__)

FingerprintCapture::FingerprintCapture()
    : m_context(nullptr)
    , m_device(nullptr)
    , m_usbFd(-1)
{
}

FingerprintCapture::~FingerprintCapture()
{
    cleanup();
}

bool FingerprintCapture::initialize()
{
    if (m_context != nullptr) {
        ANDROID_LOG("Already initialized");
        return true;
    }
    
    // Initialize GLib type system (required for GObject)
    // Note: g_type_init() is deprecated in GLib 2.36+, but we call it for compatibility
    #if GLIB_CHECK_VERSION(2, 36, 0)
    // Type system is automatically initialized in GLib 2.36+
    #else
    g_type_init();
    #endif
    
    // Workaround: Pass file descriptor to libusb via environment variable
    // This is a common pattern for Android NDK apps using libusb
    if (m_usbFd != -1) {
        char fd_str[32];
        snprintf(fd_str, sizeof(fd_str), "%d", m_usbFd);
        g_setenv("LIBUSB_FD", fd_str, TRUE);
        ANDROID_LOG("LIBUSB_FD environment variable set to: %d", m_usbFd);
    } else {
        ANDROID_LOGW("m_usbFd is -1, LIBUSB_FD not set. Device discovery might fail.");
    }
    
    // Create libfprint context
    m_context = fp_context_new();
    if (!m_context) {
        setError("Failed to create libfprint context");
        return false;
    }
    
    ANDROID_LOG("libfprint context initialized successfully");
    
    // Set GLib log handler to capture libgusb/libusb errors
    g_log_set_handler("GUsb", G_LOG_LEVEL_MASK, [](const gchar* log_domain, GLogLevelFlags log_level, const gchar* message, gpointer user_data) {
        ANDROID_LOGE("GUsb: %s", message);
    }, nullptr);
    
    g_log_set_handler("libusb", G_LOG_LEVEL_MASK, [](const gchar* log_domain, GLogLevelFlags log_level, const gchar* message, gpointer user_data) {
        ANDROID_LOGE("libusb: %s", message);
    }, nullptr);
    
    return true;
}

void FingerprintCapture::cleanup()
{
    closeDevice();
    
    if (m_context) {
        g_object_unref(m_context);
        m_context = nullptr;
    }
    
    if (m_usbFd != -1) {
        close(m_usbFd);
        m_usbFd = -1;
    }
}

int FingerprintCapture::getDeviceCount()
{
    if (!m_context) {
        if (!initialize()) {
            return 0;
        }
    }
    
    // Validate context is still valid
    if (!m_context || !G_IS_OBJECT(m_context)) {
        ANDROID_LOGE("Context is invalid or corrupted");
        return 0;
    }
    
    // Get devices - fp_context_get_devices() will call fp_context_enumerate() internally if needed
    // No need to call fp_context_enumerate() explicitly here to avoid double enumeration
    ANDROID_LOG("getDeviceCount: About to call fp_context_get_devices, m_context=%p", m_context);
    GPtrArray* devices = fp_context_get_devices(m_context);
    ANDROID_LOG("getDeviceCount: fp_context_get_devices returned devices=%p", devices);
    if (!devices) {
        ANDROID_LOGE("Failed to get devices array");
        return 0;
    }
    
    // Validate devices array pointer is valid (check alignment)
    // GPtrArray should be aligned to pointer boundary
    if ((uintptr_t)devices % sizeof(void*) != 0) {
        ANDROID_LOGE("Invalid devices array alignment (possible memory corruption)");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return 0;
    }
    
    // Read len atomically to avoid race conditions
    // Use volatile to prevent compiler optimization
    volatile guint len = devices->len;
    
    ANDROID_LOG("getDeviceCount: devices array len=%u, pdata=%p", len, devices->pdata);
    
    // Sanity check: device count should be reasonable (max 100 devices)
    // Also check if len is a reasonable value (not a pointer value)
    if (len > 100 || len < 0) {
        ANDROID_LOGE("Invalid device count: %u (possible memory corruption)", len);
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return 0;
    }
    
    int count = (int)len;
    
    ANDROID_LOG("Found %d fingerprint device(s)", count);
    
    if (count == 0) {
        ANDROID_LOGE("No devices found. libusb may not be able to access USB devices on Android.");
        ANDROID_LOGE("libusb requires file descriptor from Android USB Host API.");
    } else {
        ANDROID_LOG("Device list is valid, count=%d", count);
    }
    
    // Note: fp_context_get_devices() returns (transfer none), so we don't unref the array
    // The array is owned by the FpContext and will be freed when the context is destroyed
    
    return count;
}

bool FingerprintCapture::openDevice(int deviceIndex)
{
    if (!m_context) {
        if (!initialize()) {
            return false;
        }
    }
    
    // Close existing device if any
    closeDevice();
    
    // Get available devices
    GPtrArray* devices = fp_context_get_devices(m_context);
    if (!devices) {
        setError("Failed to get devices array");
        return false;
    }
    
    // Validate devices array (GPtrArray is a struct, not a GObject)
    // Just check if pointer is valid
    if (devices == nullptr) {
        setError("Invalid devices array pointer");
        return false;
    }
    
    int deviceCount = (int)devices->len;
    
    // Sanity check: device count should be reasonable
    if (deviceCount < 0 || deviceCount > 100) {
        ANDROID_LOGE("Invalid device count: %d (possible memory corruption)", deviceCount);
        setError("Invalid device count");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    if (deviceCount == 0) {
        setError("No fingerprint devices found");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    if (deviceIndex < 0 || deviceIndex >= deviceCount) {
        ANDROID_LOGE("Invalid device index: %d (available: 0-%d)", deviceIndex, deviceCount - 1);
        setError("Invalid device index");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Get device from array
    gpointer devicePtr = g_ptr_array_index(devices, deviceIndex);
    if (!devicePtr) {
        ANDROID_LOGE("Failed to get device at index %d", deviceIndex);
        setError("Failed to get device");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Validate device pointer
    if (devicePtr == nullptr) {
        ANDROID_LOGE("Invalid device pointer at index %d", deviceIndex);
        setError("Invalid device pointer");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    FpDevice* device = FP_DEVICE(devicePtr);
    if (device == nullptr) {
        ANDROID_LOGE("Invalid FpDevice at index %d", deviceIndex);
        setError("Invalid FpDevice");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Take reference to device
    m_device = FP_DEVICE(g_object_ref(device));
    // Note: fp_context_get_devices() returns (transfer none), so we don't unref the array
    
    // Open device synchronously
    GError* error = nullptr;
    gboolean result = fp_device_open_sync(m_device, nullptr, &error);
    
    if (!result) {
        std::string errorMsg = "Failed to open device";
        if (error) {
            errorMsg += ": ";
            errorMsg += error->message;
            g_error_free(error);
        }
        setError(errorMsg);
        g_object_unref(m_device);
        m_device = nullptr;
        return false;
    }
    
    const char* deviceName = fp_device_get_name(m_device);
    ANDROID_LOG("Device opened successfully: %s", deviceName ? deviceName : "unknown");
    
    return true;
}

void FingerprintCapture::closeDevice()
{
    if (m_device) {
        if (fp_device_is_open(m_device)) {
            GError* error = nullptr;
            fp_device_close_sync(m_device, nullptr, &error);
            if (error) {
                ANDROID_LOGE("Error closing device: %s", error->message);
                g_error_free(error);
            }
        }
        g_object_unref(m_device);
        m_device = nullptr;
    }
}

bool FingerprintCapture::isDeviceOpen() const
{
    return m_device != nullptr && fp_device_is_open(m_device);
}

bool FingerprintCapture::captureTemplate(std::vector<uint8_t>& templateData)
{
    templateData.clear();
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    // Capture image synchronously
    GError* error = nullptr;
    FpImage* image = fp_device_capture_sync(m_device, TRUE, nullptr, &error);
    
    if (error) {
        std::string errorMsg = "Failed to capture fingerprint image: ";
        errorMsg += error->message;
        setError(errorMsg);
        g_error_free(error);
        return false;
    }
    
    if (!image) {
        setError("Failed to capture fingerprint image - no image returned");
        return false;
    }
    
    ANDROID_LOG("Fingerprint image captured successfully");
    
    // Get image data
    gsize dataLen = 0;
    const guchar* imageData = fp_image_get_data(image, &dataLen);
    
    if (!imageData || dataLen == 0) {
        std::string errorMsg = "Image data is empty";
        setError(errorMsg);
        g_object_unref(image);
        return false;
    }
    
    // Copy image data to template (raw image format)
    // Note: For enrollment, this raw image will be used by Qt app to create FP3 template
    // For verification/identification, we use FP3 templates from database
    templateData.resize(dataLen);
    memcpy(templateData.data(), imageData, dataLen);
    
    // Cleanup
    g_object_unref(image);
    
    ANDROID_LOG("Template created successfully, size: %zu bytes", templateData.size());
    
    return true;
}

bool FingerprintCapture::matchWithTemplate(const std::vector<uint8_t>& storedTemplate, bool& matched, int& score)
{
    matched = false;
    score = 0;
    
    ANDROID_LOG("matchWithTemplate called - template size: %zu bytes", storedTemplate.size());
    
    if (storedTemplate.empty()) {
        ANDROID_LOGE("Template is empty!");
        setError("Template is empty");
        return false;
    }
    
    // Log first few bytes to verify format
    if (storedTemplate.size() >= 16) {
        ANDROID_LOG("Template first 16 bytes (hex): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
            storedTemplate[0], storedTemplate[1], storedTemplate[2], storedTemplate[3],
            storedTemplate[4], storedTemplate[5], storedTemplate[6], storedTemplate[7],
            storedTemplate[8], storedTemplate[9], storedTemplate[10], storedTemplate[11],
            storedTemplate[12], storedTemplate[13], storedTemplate[14], storedTemplate[15]);
    }
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    // Deserialize stored template (FP3 format)
    GError* error = nullptr;
    ANDROID_LOG("Attempting to deserialize template (size: %zu bytes)...", storedTemplate.size());
    FpPrint* storedPrint = fp_print_deserialize(storedTemplate.data(), storedTemplate.size(), &error);
    if (error) {
        std::string errorMsg = "Failed to deserialize template: ";
        errorMsg += error->message;
        ANDROID_LOGE("Template deserialization failed: %s (code: %d)", error->message, error->code);
        ANDROID_LOGE("Template might not be in FP3 format or is corrupted");
        setError(errorMsg);
        g_error_free(error);
        return false;
    }
    
    ANDROID_LOG("Template deserialized successfully, starting verification...");
    ANDROID_LOG("About to call fp_device_verify_sync - device=%p, storedPrint=%p", m_device, storedPrint);
    
    // Verify - capture and match in one step (like Qt does)
    FpPrint* newPrint = nullptr;
    gboolean match = FALSE;
    
    ANDROID_LOG("Calling fp_device_verify_sync - waiting for finger scan...");
    gboolean result = fp_device_verify_sync(
        m_device,
        storedPrint,
        nullptr, // cancellable
        nullptr, // verify_cb
        nullptr, // verify_data
        &match,
        &newPrint,
        &error
    );
    ANDROID_LOG("fp_device_verify_sync returned: result=%d, match=%d, error=%p", result, match, error);
    
    if (error) {
        if (error->domain == FP_DEVICE_ERROR && error->code == FP_DEVICE_ERROR_DATA_NOT_FOUND) {
            // No match - this is normal for failed verification
            ANDROID_LOG("Fingerprint scanned but NO MATCH");
            matched = false;
            score = 0;
            g_error_free(error);
            g_object_unref(storedPrint);
            if (newPrint) {
                g_object_unref(newPrint);
            }
            return true; // Successfully completed, just no match
        }
        
        std::string errorMsg = "Verification failed: ";
        errorMsg += error->message;
        setError(errorMsg);
        g_error_free(error);
        g_object_unref(storedPrint);
        if (newPrint) {
            g_object_unref(newPrint);
        }
        return false;
    }
    
    if (!result) {
        setError("Verification failed - no result returned");
        g_object_unref(storedPrint);
        if (newPrint) {
            g_object_unref(newPrint);
        }
        return false;
    }
    
    matched = (match == TRUE);
    
    // Calculate score based on match
    if (matched) {
        score = 95; // libfprint doesn't provide detailed score, just match/no-match
        ANDROID_LOG("✓ FINGERPRINT MATCHED!");
    } else {
        score = 30; // Low score for no match
        ANDROID_LOG("✗ Fingerprint does not match");
    }
    
    g_object_unref(storedPrint);
    if (newPrint) {
        g_object_unref(newPrint);
    }
    
    ANDROID_LOG("Verification completed: matched=%s, score=%d", matched ? "YES" : "NO", score);
    
    return true;
}

bool FingerprintCapture::identifyUser(const std::map<int, std::vector<uint8_t>>& templates, int& matchedUserId, int& score)
{
    matchedUserId = -1;
    score = 0;
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    if (templates.empty()) {
        setError("No templates provided");
        return false;
    }
    
    ANDROID_LOG("identifyUser called - preparing gallery for %zu users...", templates.size());
    
    if (templates.empty()) {
        ANDROID_LOGE("No templates provided for identification");
        setError("No templates provided");
        return false;
    }
    
    // Log template info
    for (const auto& pair : templates) {
        ANDROID_LOG("User %d: template size = %zu bytes", pair.first, pair.second.size());
        if (pair.second.empty()) {
            ANDROID_LOGW("User %d has empty template, skipping", pair.first);
        } else if (pair.second.size() >= 16) {
            ANDROID_LOG("User %d: first 16 bytes (hex): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
                pair.first,
                pair.second[0], pair.second[1], pair.second[2], pair.second[3],
                pair.second[4], pair.second[5], pair.second[6], pair.second[7],
                pair.second[8], pair.second[9], pair.second[10], pair.second[11],
                pair.second[12], pair.second[13], pair.second[14], pair.second[15]);
        }
    }
    
    // Create gallery (like Qt does)
    GPtrArray* gallery = g_ptr_array_new_with_free_func(g_object_unref);
    std::map<FpPrint*, int> printToIdMap;
    
    // Deserialize all templates
    int validTemplates = 0;
    for (const auto& pair : templates) {
        int userId = pair.first;
        const std::vector<uint8_t>& templateData = pair.second;
        
        if (templateData.empty()) {
            ANDROID_LOGW("Skipping user %d: empty template", userId);
            continue;
        }
        
        ANDROID_LOG("Deserializing template for user %d (size: %zu bytes)...", userId, templateData.size());
        GError* error = nullptr;
        FpPrint* print = fp_print_deserialize(templateData.data(), templateData.size(), &error);
        if (error) {
            ANDROID_LOGE("Skipping invalid template for user %d: %s (code: %d)", userId, error->message, error->code);
            ANDROID_LOGE("Template might not be in FP3 format or is corrupted (size: %zu bytes)", templateData.size());
            g_error_free(error);
            continue;
        }
        
        validTemplates++;
        
        g_ptr_array_add(gallery, print); // print is owned by gallery now
        printToIdMap[print] = userId;
    }
    
    if (gallery->len == 0) {
        setError("No valid templates loaded");
        g_ptr_array_unref(gallery);
        return false;
    }
    
    ANDROID_LOG("Gallery prepared. Valid templates: %d/%zu (gallery size: %u)", validTemplates, templates.size(), gallery->len);
    
    if (gallery->len == 0) {
        ANDROID_LOGE("No valid templates in gallery! All templates failed to deserialize.");
        setError("No valid templates in gallery");
        g_ptr_array_unref(gallery);
        return false;
    }
    ANDROID_LOG("Starting identification scan...");
    ANDROID_LOG("About to call fp_device_identify_sync - device=%p, gallery=%p (%u prints)", m_device, gallery, gallery->len);
    
    // Identify - capture and match against gallery (like Qt does)
    GError* error = nullptr;
    FpPrint* matchPrint = nullptr;
    FpPrint* newPrint = nullptr;
    
    ANDROID_LOG("Calling fp_device_identify_sync - waiting for finger scan...");
    gboolean result = fp_device_identify_sync(
        m_device,
        gallery,
        nullptr, // cancellable
        nullptr, // match_cb
        nullptr, // match_data
        &matchPrint, // return matching print
        &newPrint,   // return new print
        &error
    );
    ANDROID_LOG("fp_device_identify_sync returned: result=%d, matchPrint=%p, error=%p", result, matchPrint, error);
    
    if (error) {
        if (error->domain == FP_DEVICE_ERROR && error->code == FP_DEVICE_ERROR_DATA_NOT_FOUND) {
            ANDROID_LOG("Identify: No match found (DATA_NOT_FOUND)");
        } else {
            std::string errorMsg = "Identification failed: ";
            errorMsg += error->message;
            setError(errorMsg);
            ANDROID_LOGE("%s", errorMsg.c_str());
        }
        g_error_free(error);
    } else if (matchPrint) {
        // Found a match!
        auto it = printToIdMap.find(matchPrint);
        if (it != printToIdMap.end()) {
            matchedUserId = it->second;
            score = 95; // High confidence match
            ANDROID_LOG("✓ IDENTIFICATION MATCH: User ID %d", matchedUserId);
        } else {
            ANDROID_LOGE("Match returned but not found in map!");
        }
    } else {
        ANDROID_LOG("Identification completed: No match found.");
    }
    
    // Cleanup
    g_ptr_array_unref(gallery);
    if (newPrint) {
        g_object_unref(newPrint);
    }
    
    return true;
}

bool FingerprintCapture::setUsbFileDescriptor(int fd)
{
    if (fd < 0) {
        setError("Invalid file descriptor");
        return false;
    }
    
    ANDROID_LOG("Setting USB file descriptor: %d", fd);
    
    // Close previous file descriptor if any
    if (m_usbFd != -1 && m_usbFd != fd) {
        close(m_usbFd);
    }
    
    m_usbFd = fd;
    
    // CRITICAL: Set LIBUSB_FD environment variable BEFORE creating context
    // This ensures libgusb can wrap the file descriptor during initialization
    char fd_str[32];
    snprintf(fd_str, sizeof(fd_str), "%d", fd);
    setenv("LIBUSB_FD", fd_str, 1);
    ANDROID_LOG("Set LIBUSB_FD environment variable to: %s (BEFORE context initialization)", fd_str);
    
    // Ensure context is initialized AFTER setting environment variable
    if (!m_context) {
        if (!initialize()) {
            ANDROID_LOGE("Failed to initialize context after setting file descriptor");
            return false;
        }
    }
    
    // Use the new libfprint API function to integrate Android file descriptor
    ANDROID_LOG("About to call fp_context_set_android_usb_fd: context=%p, fd=%d", m_context, fd);
    if (!m_context) {
        ANDROID_LOGE("ERROR: m_context is NULL!");
        setError("Context is NULL");
        return false;
    }
    gboolean result = fp_context_set_android_usb_fd(m_context, fd);
    ANDROID_LOG("fp_context_set_android_usb_fd returned: %d", result);
    if (result) {
        ANDROID_LOG("✓✓✓ SUCCESS: fp_context_set_android_usb_fd succeeded!");
        
        // Device enumeration will happen automatically when fp_context_get_devices() is called
        // No need to trigger explicit enumeration here
        
        return true;
    } else {
        ANDROID_LOGE("✗ fp_context_set_android_usb_fd failed");
        setError("Failed to integrate Android USB file descriptor with libfprint");
        return false;
    }
}

void FingerprintCapture::setError(const std::string& error)
{
    m_lastError = error;
    ANDROID_LOGE("%s", error.c_str());
}

