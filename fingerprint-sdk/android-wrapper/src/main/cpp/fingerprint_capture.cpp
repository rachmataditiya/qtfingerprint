#include "fingerprint_capture.h"
#include <android/log.h>
#include <cstring>
#include <unistd.h> // For usleep
#include <stdint.h> // For uintptr_t

// Include libfprint headers
extern "C" {
#include <glib.h>
#include <glib-object.h>
#include <libfprint-2/fprint.h>
#include <libusb-1.0/libusb.h> // For libusb_wrap_sys_device
#include <gusb-1/gusb/gusb-context-private.h> // For _g_usb_context_get_context
#include <dlfcn.h> // For dlsym
}

// Define FpContextPrivate structure to access internal data
// This matches the structure in libfprint/fp-context.c
typedef struct {
    GUsbContext  *usb_ctx;
    GCancellable *cancellable;
    GSList       *sources;
    gint          pending_devices;
    gboolean      enumerated;
    GArray       *drivers;
    GPtrArray    *devices;
} FpContextPrivate;

// Function to get private data from FpContext
// G_DEFINE_TYPE_WITH_PRIVATE creates this function automatically
// We need to declare it here since it's not in public API
// The function name is: fp_context_get_instance_private
extern "C" {
    // This function is generated by G_DEFINE_TYPE_WITH_PRIVATE macro
    // Signature: gpointer fp_context_get_instance_private(FpContext* self)
    // We'll use GObject introspection to get it
    typedef gpointer (*FpContextGetInstancePrivateFunc)(FpContext*);
}

#include <android/log.h>
#define ANDROID_LOG_TAG "FingerprintCapture"
#define ANDROID_LOG(...) __android_log_print(ANDROID_LOG_INFO, ANDROID_LOG_TAG, __VA_ARGS__)
#define ANDROID_LOGW(...) __android_log_print(ANDROID_LOG_WARN, ANDROID_LOG_TAG, __VA_ARGS__)
#define ANDROID_LOGE(...) __android_log_print(ANDROID_LOG_ERROR, ANDROID_LOG_TAG, __VA_ARGS__)

FingerprintCapture::FingerprintCapture()
    : m_context(nullptr)
    , m_device(nullptr)
    , m_usbFd(-1)
{
}

FingerprintCapture::~FingerprintCapture()
{
    cleanup();
}

bool FingerprintCapture::initialize()
{
    if (m_context != nullptr) {
        ANDROID_LOG("Already initialized");
        return true;
    }
    
    // Initialize GLib type system (required for GObject)
    // Note: g_type_init() is deprecated in GLib 2.36+, but we call it for compatibility
    #if GLIB_CHECK_VERSION(2, 36, 0)
    // Type system is automatically initialized in GLib 2.36+
    #else
    g_type_init();
    #endif
    
    // Workaround: Pass file descriptor to libusb via environment variable
    // This is a common pattern for Android NDK apps using libusb
    if (m_usbFd != -1) {
        char fd_str[32];
        snprintf(fd_str, sizeof(fd_str), "%d", m_usbFd);
        g_setenv("LIBUSB_FD", fd_str, TRUE);
        ANDROID_LOG("LIBUSB_FD environment variable set to: %d", m_usbFd);
    } else {
        ANDROID_LOGW("m_usbFd is -1, LIBUSB_FD not set. Device discovery might fail.");
    }
    
    // Create libfprint context
    m_context = fp_context_new();
    if (!m_context) {
        setError("Failed to create libfprint context");
        return false;
    }
    
    ANDROID_LOG("libfprint context initialized successfully");
    
    // Set GLib log handler to capture libgusb/libusb errors
    g_log_set_handler("GUsb", G_LOG_LEVEL_MASK, [](const gchar* log_domain, GLogLevelFlags log_level, const gchar* message, gpointer user_data) {
        ANDROID_LOGE("GUsb: %s", message);
    }, nullptr);
    
    g_log_set_handler("libusb", G_LOG_LEVEL_MASK, [](const gchar* log_domain, GLogLevelFlags log_level, const gchar* message, gpointer user_data) {
        ANDROID_LOGE("libusb: %s", message);
    }, nullptr);
    
    return true;
}

void FingerprintCapture::cleanup()
{
    closeDevice();
    
    if (m_context) {
        g_object_unref(m_context);
        m_context = nullptr;
    }
    
    if (m_usbFd != -1) {
        close(m_usbFd);
        m_usbFd = -1;
    }
}

int FingerprintCapture::getDeviceCount()
{
    if (!m_context) {
        if (!initialize()) {
            return 0;
        }
    }
    
    // Validate context is still valid
    if (!m_context || !G_IS_OBJECT(m_context)) {
        ANDROID_LOGE("Context is invalid or corrupted");
        return 0;
    }
    
    // Get devices - fp_context_get_devices() will call fp_context_enumerate() internally if needed
    // No need to call fp_context_enumerate() explicitly here to avoid double enumeration
    ANDROID_LOG("getDeviceCount: About to call fp_context_get_devices, m_context=%p", m_context);
    GPtrArray* devices = fp_context_get_devices(m_context);
    ANDROID_LOG("getDeviceCount: fp_context_get_devices returned devices=%p", devices);
    if (!devices) {
        ANDROID_LOGE("Failed to get devices array");
        return 0;
    }
    
    // Validate devices array pointer is valid (check alignment)
    // GPtrArray should be aligned to pointer boundary
    if ((uintptr_t)devices % sizeof(void*) != 0) {
        ANDROID_LOGE("Invalid devices array alignment (possible memory corruption)");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return 0;
    }
    
    // Read len atomically to avoid race conditions
    // Use volatile to prevent compiler optimization
    volatile guint len = devices->len;
    
    ANDROID_LOG("getDeviceCount: devices array len=%u, pdata=%p", len, devices->pdata);
    
    // Sanity check: device count should be reasonable (max 100 devices)
    // Also check if len is a reasonable value (not a pointer value)
    if (len > 100 || len < 0) {
        ANDROID_LOGE("Invalid device count: %u (possible memory corruption)", len);
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return 0;
    }
    
    int count = (int)len;
    
    ANDROID_LOG("Found %d fingerprint device(s)", count);
    
    if (count == 0) {
        ANDROID_LOGE("No devices found. libusb may not be able to access USB devices on Android.");
        ANDROID_LOGE("libusb requires file descriptor from Android USB Host API.");
    } else {
        ANDROID_LOG("Device list is valid, count=%d", count);
    }
    
    // Note: fp_context_get_devices() returns (transfer none), so we don't unref the array
    // The array is owned by the FpContext and will be freed when the context is destroyed
    
    return count;
}

bool FingerprintCapture::openDevice(int deviceIndex)
{
    if (!m_context) {
        if (!initialize()) {
            return false;
        }
    }
    
    // Close existing device if any
    closeDevice();
    
    // Get available devices
    GPtrArray* devices = fp_context_get_devices(m_context);
    if (!devices) {
        setError("Failed to get devices array");
        return false;
    }
    
    // Validate devices array (GPtrArray is a struct, not a GObject)
    // Just check if pointer is valid
    if (devices == nullptr) {
        setError("Invalid devices array pointer");
        return false;
    }
    
    int deviceCount = (int)devices->len;
    
    // Sanity check: device count should be reasonable
    if (deviceCount < 0 || deviceCount > 100) {
        ANDROID_LOGE("Invalid device count: %d (possible memory corruption)", deviceCount);
        setError("Invalid device count");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    if (deviceCount == 0) {
        setError("No fingerprint devices found");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    if (deviceIndex < 0 || deviceIndex >= deviceCount) {
        ANDROID_LOGE("Invalid device index: %d (available: 0-%d)", deviceIndex, deviceCount - 1);
        setError("Invalid device index");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Get device from array
    gpointer devicePtr = g_ptr_array_index(devices, deviceIndex);
    if (!devicePtr) {
        ANDROID_LOGE("Failed to get device at index %d", deviceIndex);
        setError("Failed to get device");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Validate device pointer
    if (devicePtr == nullptr) {
        ANDROID_LOGE("Invalid device pointer at index %d", deviceIndex);
        setError("Invalid device pointer");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    FpDevice* device = FP_DEVICE(devicePtr);
    if (device == nullptr) {
        ANDROID_LOGE("Invalid FpDevice at index %d", deviceIndex);
        setError("Invalid FpDevice");
        // Note: fp_context_get_devices() returns (transfer none), so we don't unref
        return false;
    }
    
    // Take reference to device
    m_device = FP_DEVICE(g_object_ref(device));
    // Note: fp_context_get_devices() returns (transfer none), so we don't unref the array
    
    // Open device synchronously
    GError* error = nullptr;
    gboolean result = fp_device_open_sync(m_device, nullptr, &error);
    
    if (!result) {
        std::string errorMsg = "Failed to open device";
        if (error) {
            errorMsg += ": ";
            errorMsg += error->message;
            g_error_free(error);
        }
        setError(errorMsg);
        g_object_unref(m_device);
        m_device = nullptr;
        return false;
    }
    
    const char* deviceName = fp_device_get_name(m_device);
    ANDROID_LOG("Device opened successfully: %s", deviceName ? deviceName : "unknown");
    
    return true;
}

void FingerprintCapture::closeDevice()
{
    if (m_device) {
        if (fp_device_is_open(m_device)) {
            GError* error = nullptr;
            fp_device_close_sync(m_device, nullptr, &error);
            if (error) {
                ANDROID_LOGE("Error closing device: %s", error->message);
                g_error_free(error);
            }
        }
        g_object_unref(m_device);
        m_device = nullptr;
    }
}

bool FingerprintCapture::isDeviceOpen() const
{
    return m_device != nullptr && fp_device_is_open(m_device);
}

bool FingerprintCapture::captureTemplate(std::vector<uint8_t>& templateData)
{
    templateData.clear();
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    // Capture image synchronously
    GError* error = nullptr;
    FpImage* image = fp_device_capture_sync(m_device, TRUE, nullptr, &error);
    
    if (error) {
        std::string errorMsg = "Failed to capture fingerprint image: ";
        errorMsg += error->message;
        setError(errorMsg);
        g_error_free(error);
        return false;
    }
    
    if (!image) {
        setError("Failed to capture fingerprint image - no image returned");
        return false;
    }
    
    ANDROID_LOG("Fingerprint image captured successfully");
    
    // Get image data
    gsize dataLen = 0;
    const guchar* imageData = fp_image_get_data(image, &dataLen);
    
    if (!imageData || dataLen == 0) {
        std::string errorMsg = "Image data is empty";
        setError(errorMsg);
        g_object_unref(image);
        return false;
    }
    
    // For single capture, return raw image data (not FP3 template)
    // This is used for verification/identification where we match against stored FP3 templates
    templateData.resize(dataLen);
    memcpy(templateData.data(), imageData, dataLen);
    
    // Cleanup
    g_object_unref(image);
    
    ANDROID_LOG("Template created successfully, size: %zu bytes", templateData.size());
    
    return true;
}

bool FingerprintCapture::enrollFingerprint(std::vector<uint8_t>& templateData)
{
    templateData.clear();
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    ANDROID_LOG("Starting enrollment (fp_device_enroll_sync will perform all required scans)...");
    
    // Create FpPrint from device with metadata (required for serialization)
    FpPrint* print = fp_print_new(m_device);
    if (!print) {
        setError("Failed to create print");
        return false;
    }
    
    // Set required metadata to avoid NULL assertions during serialization
    fp_print_set_username(print, "user");
    fp_print_set_finger(print, FP_FINGER_UNKNOWN);
    fp_print_set_description(print, "enrolled");
    
    // Use fp_device_enroll_sync to perform full enrollment (all required scans internally)
    // This will create a valid FP3 template with NBIS data
    GError* enrollError = nullptr;
    FpPrint* enrolledPrint = fp_device_enroll_sync(
        m_device,
        print,  // existing print to add to
        nullptr, // cancellable
        nullptr, // enroll_cb
        nullptr, // enroll_data
        &enrollError
    );
    
    if (enrollError) {
        std::string errorMsg = "Failed to enroll: ";
        errorMsg += enrollError->message;
        setError(errorMsg);
        g_error_free(enrollError);
        g_object_unref(print);
        return false;
    }
    
    if (!enrolledPrint) {
        setError("Enrollment failed - no print returned");
        g_object_unref(print);
        return false;
    }
    
    // Use the enrolled print (or the original if same object)
    FpPrint* printToSerialize = enrolledPrint;
    
    // Ensure metadata is set before serialization
    const gchar* existing_username = fp_print_get_username(printToSerialize);
    if (!existing_username || strlen(existing_username) == 0) {
        fp_print_set_username(printToSerialize, "enrolled_user");
    }
    
    const gchar* existing_desc = fp_print_get_description(printToSerialize);
    if (!existing_desc || strlen(existing_desc) == 0) {
        fp_print_set_description(printToSerialize, "fingerprint");
    }
    
    // Serialize print to FP3 format
    gsize serializedLen = 0;
    guchar* serializedData = nullptr;
    GError* serializeError = nullptr;
    gboolean serializeResult = fp_print_serialize(printToSerialize, &serializedData, &serializedLen, &serializeError);
    if (!serializeResult || serializeError || !serializedData || serializedLen == 0) {
        std::string errorMsg = "Failed to serialize print";
        if (serializeError) {
            errorMsg += ": ";
            errorMsg += serializeError->message;
            g_error_free(serializeError);
        }
        setError(errorMsg);
        if (serializedData) {
            g_free(serializedData);
        }
        g_object_unref(print);
        if (enrolledPrint != print) {
            g_object_unref(enrolledPrint);
        }
        return false;
    }
    
    // Copy serialized data to template
    templateData.resize(serializedLen);
    memcpy(templateData.data(), serializedData, serializedLen);
    
    // Free serialized data (fp_print_serialize allocates memory)
    g_free(serializedData);
    
    // Cleanup
    g_object_unref(print);
    if (enrolledPrint != print) {
        g_object_unref(enrolledPrint);
    }
    
    ANDROID_LOG("Enrollment completed successfully, template size: %zu bytes", templateData.size());
    
    return true;
}

bool FingerprintCapture::matchWithTemplate(const std::vector<uint8_t>& storedTemplate, bool& matched, int& score)
{
    matched = false;
    score = 0;
    
    ANDROID_LOG("matchWithTemplate called - template size: %zu bytes", storedTemplate.size());
    
    if (storedTemplate.empty()) {
        ANDROID_LOGE("Template is empty!");
        setError("Template is empty");
        return false;
    }
    
    // Log first few bytes to verify format
    if (storedTemplate.size() >= 16) {
        ANDROID_LOG("Template first 16 bytes (hex): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
            storedTemplate[0], storedTemplate[1], storedTemplate[2], storedTemplate[3],
            storedTemplate[4], storedTemplate[5], storedTemplate[6], storedTemplate[7],
            storedTemplate[8], storedTemplate[9], storedTemplate[10], storedTemplate[11],
            storedTemplate[12], storedTemplate[13], storedTemplate[14], storedTemplate[15]);
    }
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    // Deserialize stored template (FP3 format)
    GError* error = nullptr;
    ANDROID_LOG("Attempting to deserialize template (size: %zu bytes)...", storedTemplate.size());
    FpPrint* storedPrint = fp_print_deserialize(storedTemplate.data(), storedTemplate.size(), &error);
    if (error) {
        std::string errorMsg = "Failed to deserialize template: ";
        errorMsg += error->message;
        ANDROID_LOGE("Template deserialization failed: %s (code: %d)", error->message, error->code);
        ANDROID_LOGE("Template might not be in FP3 format or is corrupted");
        setError(errorMsg);
        g_error_free(error);
        return false;
    }
    
    ANDROID_LOG("Template deserialized successfully, starting verification...");
    ANDROID_LOG("About to call fp_device_verify_sync - device=%p, storedPrint=%p", m_device, storedPrint);
    
    // Verify - capture and match in one step (like Qt does)
    FpPrint* newPrint = nullptr;
    gboolean match = FALSE;
    
    ANDROID_LOG("Calling fp_device_verify_sync - waiting for finger scan...");
    gboolean result = fp_device_verify_sync(
        m_device,
        storedPrint,
        nullptr, // cancellable
        nullptr, // verify_cb
        nullptr, // verify_data
        &match,
        &newPrint,
        &error
    );
    ANDROID_LOG("fp_device_verify_sync returned: result=%d, match=%d, error=%p", result, match, error);
    
    if (error) {
        // Check error domain and code
        ANDROID_LOG("Error from fp_device_verify_sync: domain=%d, code=%d, message=%s", 
            error->domain, error->code, error->message);
        
        if (error->domain == FP_DEVICE_ERROR) {
            if (error->code == FP_DEVICE_ERROR_DATA_NOT_FOUND) {
                // No match - this is normal for failed verification (fingerprint scanned but doesn't match)
                ANDROID_LOG("Fingerprint scanned but NO MATCH");
                matched = false;
                score = 0;
                g_error_free(error);
                g_object_unref(storedPrint);
                if (newPrint) {
                    g_object_unref(newPrint);
                }
                return true; // Successfully completed, just no match
            } else if (error->code == FP_DEVICE_ERROR_NOT_OPEN) {
                ANDROID_LOGE("Device not open - cannot verify");
                setError("Device not open");
                g_error_free(error);
                g_object_unref(storedPrint);
                if (newPrint) {
                    g_object_unref(newPrint);
                }
                return false;
            } else if (error->code == FP_DEVICE_ERROR_BUSY) {
                ANDROID_LOGE("Device is busy - another operation in progress");
                setError("Device is busy");
                g_error_free(error);
                g_object_unref(storedPrint);
                if (newPrint) {
                    g_object_unref(newPrint);
                }
                return false;
            }
        }
        
        // Check for retry errors (these are not fatal, but indicate user needs to retry)
        // FP_DEVICE_RETRY domain indicates user action needed (remove finger, try again, etc.)
        // For now, we'll treat these as errors that should be reported to user
        std::string errorMsg = "Verification failed: ";
        errorMsg += error->message;
        ANDROID_LOGE("Verification error: %s", errorMsg.c_str());
        setError(errorMsg);
        g_error_free(error);
        g_object_unref(storedPrint);
        if (newPrint) {
            g_object_unref(newPrint);
        }
        return false;
    }
    
    if (!result) {
        setError("Verification failed - no result returned");
        g_object_unref(storedPrint);
        if (newPrint) {
            g_object_unref(newPrint);
        }
        return false;
    }
    
    matched = (match == TRUE);
    
    // Calculate score based on match
    if (matched) {
        score = 95; // libfprint doesn't provide detailed score, just match/no-match
        ANDROID_LOG("✓ FINGERPRINT MATCHED!");
    } else {
        score = 30; // Low score for no match
        ANDROID_LOG("✗ Fingerprint does not match");
    }
    
    g_object_unref(storedPrint);
    if (newPrint) {
        g_object_unref(newPrint);
    }
    
    ANDROID_LOG("Verification completed: matched=%s, score=%d", matched ? "YES" : "NO", score);
    
    return true;
}

bool FingerprintCapture::identifyUser(const std::vector<std::pair<int, std::vector<uint8_t>>>& templates, int& matchedIndex, int& score)
{
    matchedIndex = -1;
    score = 0;
    
    if (!m_device) {
        setError("Device not open. Call openDevice() first.");
        return false;
    }
    
    if (!fp_device_is_open(m_device)) {
        setError("Device is not open");
        return false;
    }
    
    if (templates.empty()) {
        setError("No templates provided");
        return false;
    }
    
    ANDROID_LOG("identifyUser called - preparing gallery for %zu templates (all fingers)...", templates.size());
    
    // Log template info
    for (size_t i = 0; i < templates.size(); i++) {
        const auto& pair = templates[i];
        ANDROID_LOG("Template %zu: User %d, size = %zu bytes", i, pair.first, pair.second.size());
        if (pair.second.empty()) {
            ANDROID_LOGW("Template %zu (User %d) has empty template, skipping", i, pair.first);
        } else if (pair.second.size() >= 16) {
            ANDROID_LOG("Template %zu (User %d): first 16 bytes (hex): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
                i, pair.first,
                pair.second[0], pair.second[1], pair.second[2], pair.second[3],
                pair.second[4], pair.second[5], pair.second[6], pair.second[7],
                pair.second[8], pair.second[9], pair.second[10], pair.second[11],
                pair.second[12], pair.second[13], pair.second[14], pair.second[15]);
        }
    }
    
    // Create gallery (like Qt does)
    GPtrArray* gallery = g_ptr_array_new_with_free_func(g_object_unref);
    std::map<FpPrint*, size_t> printToIndexMap; // Map FpPrint* to template index
    
    // Deserialize all templates (one per template, not per user - supports multiple fingers per user)
    int validTemplates = 0;
    for (size_t i = 0; i < templates.size(); i++) {
        const auto& pair = templates[i];
        int userId = pair.first;
        const std::vector<uint8_t>& templateData = pair.second;
        
        if (templateData.empty()) {
            ANDROID_LOGW("Skipping template %zu (User %d): empty template", i, userId);
            continue;
        }
        
        ANDROID_LOG("Deserializing template %zu for user %d (size: %zu bytes)...", i, userId, templateData.size());
        
        // Log first few bytes for debugging
        if (templateData.size() >= 16) {
            ANDROID_LOG("Template %zu header (first 16 bytes): %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
                i,
                templateData[0], templateData[1], templateData[2], templateData[3],
                templateData[4], templateData[5], templateData[6], templateData[7],
                templateData[8], templateData[9], templateData[10], templateData[11],
                templateData[12], templateData[13], templateData[14], templateData[15]);
        }
        
        GError* error = nullptr;
        FpPrint* print = fp_print_deserialize(templateData.data(), templateData.size(), &error);
        if (error) {
            ANDROID_LOGE("Skipping invalid template %zu (User %d): %s (code: %d)", i, userId, error->message, error->code);
            ANDROID_LOGE("Template might not be in FP3 format or is corrupted (size: %zu bytes)", templateData.size());
            g_error_free(error);
            continue;
        }
        
        validTemplates++;
        ANDROID_LOG("Template %zu (User %d) deserialized successfully", i, userId);
        
        g_ptr_array_add(gallery, print); // print is owned by gallery now
        printToIndexMap[print] = i; // Map to template index (not userId, since multiple templates per user)
    }
    
    if (gallery->len == 0) {
        setError("No valid templates loaded");
        g_ptr_array_unref(gallery);
        return false;
    }
    
    ANDROID_LOG("Gallery prepared. Valid templates: %d/%zu (gallery size: %u)", validTemplates, templates.size(), gallery->len);
    
    if (gallery->len == 0) {
        ANDROID_LOGE("No valid templates in gallery! All templates failed to deserialize.");
        setError("No valid templates in gallery");
        g_ptr_array_unref(gallery);
        return false;
    }
    ANDROID_LOG("Starting identification scan...");
    ANDROID_LOG("About to call fp_device_identify_sync - device=%p, gallery=%p (%u prints)", m_device, gallery, gallery->len);
    
    // Identify - capture and match against gallery (like Qt does)
    GError* error = nullptr;
    FpPrint* matchPrint = nullptr;
    FpPrint* newPrint = nullptr;
    
    ANDROID_LOG("Calling fp_device_identify_sync - waiting for finger scan...");
    gboolean result = fp_device_identify_sync(
        m_device,
        gallery,
        nullptr, // cancellable
        nullptr, // match_cb
        nullptr, // match_data
        &matchPrint, // return matching print
        &newPrint,   // return new print
        &error
    );
    ANDROID_LOG("fp_device_identify_sync returned: result=%d, matchPrint=%p, error=%p", result, matchPrint, error);
    
    if (error) {
        ANDROID_LOG("Error from fp_device_identify_sync: domain=%d, code=%d, message=%s", 
            error->domain, error->code, error->message);
        
        if (error->domain == FP_DEVICE_ERROR) {
            if (error->code == FP_DEVICE_ERROR_DATA_NOT_FOUND) {
                // No match - this is normal for failed identification
                ANDROID_LOG("Identify: No match found (fingerprint scanned but doesn't match any user)");
                matchedIndex = -1;
                score = 0;
                g_error_free(error);
                g_ptr_array_unref(gallery);
                return true; // Successfully completed, just no match
            } else if (error->code == FP_DEVICE_ERROR_NOT_OPEN) {
                ANDROID_LOGE("Device not open - cannot identify");
                setError("Device not open");
                g_error_free(error);
                g_ptr_array_unref(gallery);
                return false;
            } else if (error->code == FP_DEVICE_ERROR_BUSY) {
                ANDROID_LOGE("Device is busy - another operation in progress");
                setError("Device is busy");
                g_error_free(error);
                g_ptr_array_unref(gallery);
                return false;
            }
        }
        
        std::string errorMsg = "Identification failed: ";
        errorMsg += error->message;
        ANDROID_LOGE("Identification error: %s", errorMsg.c_str());
        setError(errorMsg);
        g_error_free(error);
        g_ptr_array_unref(gallery);
        return false;
    } else if (matchPrint) {
        // Found a match!
        auto it = printToIndexMap.find(matchPrint);
        if (it != printToIndexMap.end()) {
            matchedIndex = static_cast<int>(it->second);
            score = 95; // High confidence match
            int matchedUserId = templates[matchedIndex].first;
            ANDROID_LOG("✓ IDENTIFICATION MATCH: Template index %d (User ID %d)", matchedIndex, matchedUserId);
        } else {
            ANDROID_LOGE("Match returned but not found in map!");
            matchedIndex = -1;
            score = 0;
        }
    } else {
        // No match found (but operation completed successfully)
        ANDROID_LOG("Identification completed: No match found.");
        matchedIndex = -1;
        score = 0;
    }
    
    // Cleanup
    g_ptr_array_unref(gallery);
    if (newPrint) {
        g_object_unref(newPrint);
    }
    
    ANDROID_LOG("Identification completed: matchedIndex=%d, score=%d", matchedIndex, score);
    
    return true; // Always return true if we got here (error cases already returned false above)
}

bool FingerprintCapture::setUsbFileDescriptor(int fd)
{
    if (fd < 0) {
        setError("Invalid file descriptor");
        return false;
    }
    
    ANDROID_LOG("Setting USB file descriptor: %d", fd);
    
    // Close previous file descriptor if any
    if (m_usbFd != -1 && m_usbFd != fd) {
        close(m_usbFd);
    }
    
    m_usbFd = fd;
    
    // CRITICAL: Set LIBUSB_FD environment variable BEFORE creating context
    // This ensures libgusb can wrap the file descriptor during initialization
    char fd_str[32];
    snprintf(fd_str, sizeof(fd_str), "%d", fd);
    setenv("LIBUSB_FD", fd_str, 1);
    ANDROID_LOG("Set LIBUSB_FD environment variable to: %s (BEFORE context initialization)", fd_str);
    
    // Ensure context is initialized AFTER setting environment variable
    if (!m_context) {
        if (!initialize()) {
            ANDROID_LOGE("Failed to initialize context after setting file descriptor");
            return false;
        }
    }
    
    // Use the new libfprint API function to integrate Android file descriptor
    ANDROID_LOG("About to call fp_context_set_android_usb_fd: context=%p, fd=%d", m_context, fd);
    if (!m_context) {
        ANDROID_LOGE("ERROR: m_context is NULL!");
        setError("Context is NULL");
        return false;
    }
    gboolean result = fp_context_set_android_usb_fd(m_context, fd);
    ANDROID_LOG("fp_context_set_android_usb_fd returned: %d", result);
    if (result) {
        ANDROID_LOG("✓✓✓ SUCCESS: fp_context_set_android_usb_fd succeeded!");
        
        // Device enumeration will happen automatically when fp_context_get_devices() is called
        // No need to trigger explicit enumeration here
        
        return true;
    } else {
        ANDROID_LOGE("✗ fp_context_set_android_usb_fd failed");
        setError("Failed to integrate Android USB file descriptor with libfprint");
        return false;
    }
}

void FingerprintCapture::setError(const std::string& error)
{
    m_lastError = error;
    ANDROID_LOGE("%s", error.c_str());
}

